// Generated by CoffeeScript 1.10.0
(function() {
  var PDF, Stream, assert, childprocess, err, error, fs, path, phantomjs;

  fs = require('fs');

  Stream = require('stream').Readable;

  childprocess = require('child_process');

  path = require('path');

  assert = require('assert');

  try {
    phantomjs = require('phantomjs');
  } catch (error) {
    err = error;
    console.log('html-pdf: Failed to load PhantomJS module.', err);
  }

  module.exports = PDF = (function() {
    function PDF(html, options) {
      var base, base1;
      this.html = html;
      this.options = options != null ? options : {};
      if (this.options.script) {
        this.script = path.normalize(this.options.script);
      } else {
        this.script = path.join(__dirname, 'scripts', 'pdf_a4_portrait.js');
      }
      if (this.options.filename) {
        this.options.filename = path.resolve(this.options.filename);
      }
      if ((base = this.options).phantomPath == null) {
        base.phantomPath = phantomjs != null ? phantomjs.path : void 0;
      }
      if ((base1 = this.options).phantomArgs == null) {
        base1.phantomArgs = [];
      }
      assert(this.options.phantomPath, "html-pdf: Failed to load PhantomJS module. You have to set the path to the PhantomJS binary using 'options.phantomPath'");
      assert(typeof this.html === 'string' && this.html.length, "html-pdf: Can't create a pdf without an html string");
      this.options.timeout = parseInt(this.options.timeout) || 30000;
    }

    PDF.prototype.toBuffer = function(callback) {
      return this.exec(function(err, res) {
        if (err) {
          return callback(err);
        }
        return fs.readFile(res.filename, function(err, buffer) {
          if (err) {
            return callback(err);
          }
          return fs.unlink(res.filename, function(err) {
            if (err) {
              return callback(err);
            }
            return callback(null, buffer);
          });
        });
      });
    };

    PDF.prototype.toStream = function(callback) {
      return this.exec(function(err, res) {
        var error1, stream;
        if (err) {
          return callback(err);
        }
        try {
          stream = fs.createReadStream(res.filename);
        } catch (error1) {
          err = error1;
          return callback(err);
        }
        stream.on('end', function() {
          return fs.unlink(res.filename, function(err) {
            if (err) {
              return console.log('html-pdf:', err);
            }
          });
        });
        return callback(null, stream);
      });
    };

    PDF.prototype.toFile = function(filename, callback) {
      assert(arguments.length > 0, 'html-pdf: The method .toFile([filename, ]callback) requires a callback.');
      if (filename instanceof Function) {
        callback = filename;
        filename = void 0;
      } else {
        this.options.filename = path.resolve(filename);
      }
      return this.exec(callback);
    };

    PDF.prototype.exec = function(callback) {
      var child, stderr, stdout, timeout;
      child = childprocess.spawn(this.options.phantomPath, [].concat(this.options.phantomArgs, [this.script]));
      stdout = [];
      stderr = [];
      timeout = setTimeout(function() {
        child.stdin.end();
        child.kill();
        if (!stderr.length) {
          return stderr = [new Buffer('html-pdf: PDF generation timeout. Phantom.js script did not exit.')];
        }
      }, this.options.timeout);
      child.stdout.on('data', function(buffer) {
        return stdout.push(buffer);
      });
      child.stderr.on('data', function(buffer) {
        stderr.push(buffer);
        child.stdin.end();
        return child.kill();
      });
      child.on('exit', function(code) {
        var data, error1, ref;
        clearTimeout(timeout);
        if (code || stderr.length) {
          err = new Error(Buffer.concat(stderr).toString() || 'html-pdf: Unknown Error');
          return callback(err);
        } else {
          try {
            data = (ref = Buffer.concat(stdout).toString()) != null ? ref.trim() : void 0;
            data = JSON.parse(data);
          } catch (error1) {
            err = error1;
            return callback(err);
          }
          return callback(null, data);
        }
      });
      return child.stdin.write(JSON.stringify({
        html: this.html,
        options: this.options
      }) + '\n', 'utf8');
    };

    return PDF;

  })();

}).call(this);
